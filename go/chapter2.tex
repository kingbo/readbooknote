\chapter{初识Go语言}
Go语言的目标之一是一致且无歧义的语法。这个特点利于使用工具来检测GO语言程序，也使得它易于学习。无用的编译错误增加了学习程序语言的难度，这点对于他用过C++模板代码并产生的打字排版错误的人是十分清楚的。

例如在C语言中函数变量和全局变量声明的语法几乎是一样的。如果你出错将意味着编译器不能够顺利地的告诉你哪一个是你所想要的。编译器在某行给出一条件像“expected ;”一样有帮助的错误信息，而那一行却不总是需要分号。

Go语言的语法器被设计成认编译器能够给出更准确的错误信息。同时它也被设计成避免依赖某种状态，因此更加容易推断错误。例如，如果你建立了一个变量并将其设置成42，编译器能够在没有明确的状态下大概猜出该变量是整型变量。如果你在函数调用中初始化该变量，编译器能够明确该变量的类型，无论函数在哪里返回。这点和C++2011的auto类型一样。

Go语言采用采用了JavaScript的分号插入思想，且比它更先进。任何行都记法分析器解释成为行尾有隐式分号插入的的完整语句。这意味着Go语言能够直接忽略用分号作为语句终结符。因此，也增加了一些限制，如强制括号样式为左括号在控制语句开始行末，而不是我们自己。碰巧你是这样的人，非常不幸，这意味着你不能使用最优的系统识别方式，为了理解代码块，视觉皮层估计需要至少需要花费无数年才能够完成优化。

本章只是Go语言的语法概览，并不包含全部的内容。某些方面在后续章节中覆盖。实际上，Go语言所有与并发相关的内容包含在第9章，Goroutines中。

\section{Go语言源文件结构}
\begin{lstlisting}
package main
import "fmt"
func main(){
   fmt.Printf("Hello World!\n")
}
\end{lstlisting}

Go语言源文件由三个部分组成。第一个部分是package语句。Go代码被放置在包中，包在Go语言中起类似C语言中的库和头文件的作用。本例中的包名是main，它是一个特殊的包。每一个Go程序必须包含一个main包，并包含一个main()函数，它是程序的入口。

第二部分是明确该源文件所要用到的包，以及如何导入它们。在上例中，我们导入了fmt包。一旦导入fmt包，冠以包的字首就能够使用该包所定义的导出类型、变量、常数和函数。在上例中，我们调用了与C语言的printf函数类似的Printf()函数，并用它在终端上输出“Hello World!”字样。

尽管Go语言使用静态编译，但是，明白import语句更接近于Java或Python的导入指令而不是C语言的include指令是很重要的，因此它们并不将源代码包含于当前的编译单元。不像Java和Python的包，Go语言的包将在代码连接的时候导入而不等到运行的时候。这样确保了Go语言的应用程序不会因为布署系统缺少相应的包而失败，但代价是增加了可执行程序文件的大小。包在Go语言中比类似Java语言的包更加重要。因为Go语言仅提供包级层次的进入控制，而Java提供到类级的层。

当使用GC编译器编译一个包时，我们将从包获得目标代码文件。它包含一个用以描述包输出类型和函数的元数据。同时也包含了该包所导入的包列表。

对main包调用6l连接器总是获得a.t文件。该文件包括了在main包中导入的每一个包的起始位置，也会依次包含更多包的起始位置。到时连接器会将所有的组合起来。

建立复杂C语言程序最令人不愉快的限制是：你要包含一个头文件，并给出它提供的库和连接标志。在Go语言中，如果是包编译，它将会连接，你不必提供连接标志给连接器，并通过import指令告诉连接器你的引用。

Go语言中余下的类型、变量和函数声明，将在本章的其余部分进行阐述。

你也许发现您想导入的两个包有相同的名字。这在Go语言中将引发问题。例子badStyleImport.go 是一个与本节开始的例子功能相同，但将fmt包名重命名为format。在导入包的时候进行重命名通常是个坏主意，因为它使得代码难以被人阅读。你仅仅在确实需要消除两个同名包的二义性时才使用。

\begin{lstlisting}
package main
import format "fmt"

func main(){
	format.Printf("Hello World!\n")
}
\end{lstlisting}

\section{变量定义}
\begin{lstlisting}[escapechar=\%]
var i int
var %Θ% float32
var eplicitly,typed, pointers *complex128
int_pointer :=&i 
another_int_point :=new(int)
generic_channel :=make(chan interface{})
\end{lstlisting}

变量的定义要首先要使用关键字var，接下来是变量名，最后是变量类型。变量声明关键字的使用使得它与其它类型的关键字明显示的区别开。

将变量类型写在变量名的后面对于熟悉C类的人来说有一些怪异，但这样更利于代码的阅读和理解。一个变量声明就是一个说明，例如，“声明变量foo为int型”。

在Go语言中可以使用诸如$\theta$这样的字符作为变量名。Go语言允许标识符开始于任何Unicode字母。在某些时候，这样做是非常有用的，比如变量名是一个数理量。尽管如此，也不要滥用：如果频繁使用的变量不能够直接从键上输入，那么维护你的代码的人是不会感激你的。

一个变量声明语句可以同时声明多个变量，同时声明的变量具有相同的类型。在C语言中，类型声明写在前面，使得同时声明的变量具有不同的类型，一些可能是指针类型，一些可能是指向指针的指针类型等等。因此，这种形式在Go语言中不可能产生二义。

我们几乎很少使用长格式进行变量声明。编写良好代码的一个关键思想是最小化范围原则。这意味着变量的作用域在其生存期内要尽可能小。即变量应该在在第一次使用该变量的部分进行声明并初始化。

Go语言提供了：=操作用于变量的声明的初始化。使用该符号，我们能够在一个语句中声明变量并给它初始化。更重要的是，我们不必为一个变量指定类型：变量的类型由其用于初始化的表达式的类型确定。

本节开始的例子第2行中展示了这种声明方式。在这个例子中也介绍了Go语言的指针语法。\lstinline$int_pointer$变量通过地址操作符(\&)进行赋值。这样的操作对于C程序员而言再熟悉不过了：该操作返回的是指向某个对象的内存地址值。然而，这个值更新Java的引用，而不是C的指针。因此，Go语言的指针不能够执行算术操作，也不能够使用它来进行数组交换。与Java的引用一样，你可以随意传递Go语言指针，而不用担心其指向的目标对象已经被销毁。它将在最后一个引被释放的时候才自动释放。不像Java引用，Go语言可以创建原始类型的指针，而不仅是结构体类型（Go语言的等价对象）。

在本例第3行中，可以通过函数返回\lstinline$int_pointer$而不会引发任何问题。这对C程序员来说是很奇怪的，因为在C语言中该指针变量是在局部声明的，超出作用域后就失效了。而Go语言会把i放置于堆栈中，但这仅仅是一个编译细节。如果地址起作用并且被函数返回，那么它将被指派到用以代替的堆栈。

第4行采用了别一种方式来创建整形指针。内建函数new()创建一个新的整型数，并返回一个指向它的指针。从语义上等价于声明一个整型变量，然后引用它的地址。无论低层将如何分配，你可以将何类型传递给new()函数，但这并不是标准的分配形式。

Go语言包括了三种特殊的类型，在本书的后续章节将揭示与slices,maps和channels相关的更多的细节。引用类型意味着我们将始终通过引用进入这些变量。如果分配一个映射类型变量给一个引用，那么将有两个变量与之相关。相此相反，如果分配一个整型变量给一个引用，那么将有两个变量拥有相同值，但是修改其中一个变量并不影响别外一个变量。

Go语言中的引用类型实例使用内建函数make()创建。其功能与new()函数相似，也执行内建类型初始化。new()函数只时简单的返回一个零值，尽管良好的风格建设我们这样做，因此并不能保证其是直接可用的。

\section{定义函数}
\begin{lstlisting}
func printf(str string, args ...interface{})(int, error){
	_, err := fmt.Printf(str, args...)
	return len(args), err
}
func main(){
	count :=1
	closure := func(msg string){
		printf("%d %s\n", count, msg)
		count++
		}
	closure ("A Message")
	closure ("Another Message")
}
\end{lstlisting}

Go语言使用关键字func进行函数声明。同变量声明一样，返回类型位于其后。其返回值可以是单值的，也可以是一个值列表。本节中的printf()函数展示了Go语言的几个重要的特性。能够返回多个值的多值函数：一个整数和一个错误。这个整数用以传递可变参数，错误用以返回fmt包中Printf()函数的错误信息。

值得请注意的是函数调用时返回多个值。这些返回值要么被忽略，要么指定给相应的变量。下划线被用于希望忽略的返回值。



\endinput